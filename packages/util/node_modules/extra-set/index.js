'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function add$(x, v) {
    return x.add(v);
}
function add(x, v) {
    return new Set(x).add(v);
}
function id(v) {
    return v;
}
function* cartesianProduct(xs, fn = null) {
    var fn = fn || id;
    var XS = xs.length;
    var vss = xs.map(x => [...x]);
    var ls = vss.map(vs => vs.length);
    var is = vss.map(vs => 0);
    while (true) {
        var a = new Set();
        for (var n = 0; n < XS; n++) {
            var i = is[n];
            var vs = vss[n], v = vs[i];
            a.add(v);
        }
        yield fn(a, a, null);
        for (var r = XS - 1; r >= 0; r--) {
            is[r]++;
            if (is[r] < ls[r])
                break;
            is[r] = 0;
        }
        if (r < 0)
            break;
    }
}
function chunk(x, n = 1, s = n) {
    var a = [];
    for (var i = 0, I = x.length; i < I; i += s)
        a.push(x.slice(i, i + n));
    return a;
}
function index(x, i = 0) {
    return i < 0 ? Math.max(x.length + i, 0) : Math.min(i, x.length);
}
function from$$1(x) {
    return Array.isArray(x) ? x : [...x];
}
function fromRange(v, V = v, s = 1) {
    var a = [];
    if (s >= 0) {
        for (; v < V; v += s)
            a.push(v);
    }
    else {
        for (; v > V; v += s)
            a.push(v);
    }
    return a;
}
function get(x, i) {
    return x[index(x, i)];
}
function getAll(x, is) {
    return is.map(i => get(x, i));
}
function random(r) {
    var a = Math.floor(r * 2 ** 31);
    return function () {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}
function permutation$(x, n = -1, r = Math.random()) {
    if (n > x.length)
        return x;
    var X = x.length, rnd = random(r);
    var n = n >= 0 ? n : Math.floor((X + 1) * rnd());
    for (var i = 0; i < n; i++) {
        var j = i + Math.floor((X - i) * rnd());
        var t = x[i];
        x[i] = x[j];
        x[j] = t;
    }
    x.length = n;
    return x;
}
function subsequenceNum(x, n, r) {
    var is = fromRange(0, x.length, 1);
    permutation$(is, n, r).sort();
    return getAll(x, is);
}
function subsequenceAny(x, r) {
    var rnd = random(r), a = [];
    for (var v of x)
        if (rnd() >= 0.5)
            a.push(v);
    return a;
}
function subsequence(x, n = -1, r = Math.random()) {
    var X = x.length;
    if (n >= 0)
        return n > X ? null : subsequenceNum(x, n, r);
    return subsequenceAny(x, r);
}
function* subsequences(x, n = -1) {
    var X = x.length;
    if (n >= X) {
        if (n === X)
            yield x;
        return;
    }
    if (n === 0 || X === 0) {
        yield [];
        return;
    }
    var y = x.slice(0, -1);
    yield* subsequences(y, n);
    for (var s of subsequences(y, n - 1)) {
        s.push(x[X - 1]);
        yield s;
    }
}
function value(x, r = Math.random()) {
    var i = Math.floor(r * x.length);
    return x[i];
}
function chunk$1(x, n = 1, s = n) {
    return chunk([...x], n, s).map(c => new Set(c));
}
function compare(x, y) {
    for (var v of x)
        if (!y.has(v))
            return 1;
    for (var v of y)
        if (!x.has(v))
            return -1;
    return 0;
}
function concat$(x, ...ys) {
    for (var y of ys) {
        for (var v of y)
            x.add(v);
    }
    return x;
}
function concat(...xs) {
    return concat$(new Set(), ...xs);
}
function count(x, ft) {
    var a = 0;
    for (var v of x)
        if (ft(v, v, x))
            a++;
    return a;
}
function countAs(x, fm) {
    var fm = fm || id;
    var a = new Map();
    for (var v of x) {
        var v1 = fm(v, v, x);
        var n = a.get(v1) || 0;
        a.set(v1, n + 1);
    }
    return a;
}
function difference$(x, y) {
    for (var v of y)
        x.delete(v);
    return x;
}
function difference(x, y) {
    var a = new Set();
    for (var v of x)
        if (!y.has(v))
            a.add(v);
    return a;
}
function drop$(x, n = 1) {
    var i = 0;
    for (var v of x) {
        if (i++ >= n)
            break;
        x.delete(v);
    }
    return x;
}
function drop(x, n = 1) {
    var i = 0, a = new Set();
    for (var v of x)
        if (i++ >= n)
            a.add(v);
    return a;
}
function* entries(x) {
    yield* x.entries();
}
function entry(x, r = Math.random()) {
    return value([...x.entries()], r);
}
function scanWhile(x, ft) {
    for (var v of x)
        if (!ft(v, v, x))
            return v;
}
function every(x, ft = null) {
    var ft = ft || id;
    return scanWhile(x, ft) === undefined;
}
function filter$(x, ft) {
    for (var v of x)
        if (!ft(v, v, x))
            x.delete(v);
    return x;
}
function filter(x, ft) {
    var a = new Set();
    for (var v of x)
        if (ft(v, v, x))
            a.add(v);
    return a;
}
function filterAt$(x, vs) {
    for (var v of x)
        if (!vs.includes(v))
            x.delete(v);
    return x;
}
function filterAt(x, vs) {
    var a = new Set();
    for (var v of vs)
        if (x.has(v))
            a.add(v);
    return a;
}
function find(x, ft) {
    for (var v of x)
        if (ft(v, v, x))
            return v;
}
function findAll(x, ft) {
    var a = [];
    for (var v of x)
        if (ft(v, v, x))
            a.push(v);
    return a;
}
function is(v) {
    return v instanceof Set;
}
function flatTo(x, n, fm, ft, a) {
    for (var v of x) {
        var v1 = fm(v, v, x);
        if (n !== 0 && ft(v1, v1, x))
            flatTo(v1, n - 1, fm, ft, a);
        else
            a.add(v1);
    }
    return a;
}
function flat(x, n = -1, fm = null, ft = null) {
    var fm = fm || id, ft = ft || is;
    return flatTo(x, n, fm, ft, new Set());
}
function flatMap(x, fm = null, ft = null) {
    var fm = fm || id, ft = ft || is;
    var a = new Set();
    for (var v of x) {
        var v1 = fm(v, v, x);
        if (ft(v1, v1, x))
            concat$(a, v1);
        else
            a.add(v1);
    }
    return a;
}
function forEach(x, fc) {
    for (var v of x)
        fc(v, v, x);
}
function from$(vs) {
    return vs instanceof Set ? vs : new Set(vs);
}
function from(vs, fm = null) {
    return new Set(fm ? from$$1(vs).map(fm) : vs);
}
function has(x, v) {
    return x.has(v);
}
function hasSubset(x, y) {
    for (var v of y)
        if (!x.has(v))
            return false;
    return true;
}
function head(x, vd) {
    for (var v of x)
        return v;
    return vd;
}
function intersection$(x, y) {
    for (var v of x)
        if (!y.has(v))
            x.delete(v);
    return x;
}
function intersection(x, y) {
    var a = new Set();
    for (var v of y)
        if (x.has(v))
            a.add(v);
    return a;
}
function isDisjoint(x, y) {
    for (var v of y)
        if (x.has(v))
            return false;
    return true;
}
function isEmpty(x) {
    return x.size === 0;
}
function isEqual(x, y) {
    return x.size === y.size && compare(x, y) === 0;
}
function join(x, sep = ",") {
    return [...x].join(sep);
}
function length(x) {
    return x.size;
}
function map$(x, ft) {
    var vs = [];
    for (var v of x)
        vs.push(ft(v, v, x));
    x.clear();
    return concat$(x, vs);
}
function map(x, ft) {
    var a = new Set();
    for (var v of x)
        a.add(ft(v, v, x));
    return a;
}
function cmp(a, b) {
    return a < b ? -1 : (a > b ? 1 : 0);
}
function range(x, fc = null, fm = null) {
    var fc = fc || cmp, fm = fm || id;
    var mu, mv;
    var nu, nv;
    var i = 0;
    for (var u of x) {
        var v = fm(u, u, x);
        if (i === 0 || fc(v, mv) < 0) {
            mu = u;
            mv = v;
        }
        if (i === 0 || fc(v, nv) > 0) {
            nu = u;
            nv = v;
        }
        i++;
    }
    return [[mu, mu], [nu, nu]];
}
function max(x, fc = null, fm = null) {
    return range(x, fc, fm)[1];
}
function min(x, fc = null, fm = null) {
    return range(x, fc, fm)[0];
}
function partition(x, ft) {
    var t = new Set();
    var f = new Set();
    for (var v of x) {
        if (ft(v, v, x))
            t.add(v);
        else
            f.add(v);
    }
    return [t, f];
}
function partitionAs(x, fm) {
    var fm = fm || id;
    var a = new Map();
    for (var v of x) {
        var v1 = fm(v, v, x);
        if (!a.has(v1))
            a.set(v1, new Set());
        a.get(v1).add(v);
    }
    return a;
}
function reduce(x, fr, acc) {
    var init = arguments.length <= 2;
    for (var v of x) {
        if (init) {
            acc = v;
            init = false;
        }
        else
            acc = fr(acc, v, v, x);
    }
    return acc;
}
function reject$(x, ft) {
    for (var v of x)
        if (ft(v, v, x))
            x.delete(v);
    return x;
}
function reject(x, ft) {
    var a = new Set();
    for (var v of x)
        if (!ft(v, v, x))
            a.add(v);
    return a;
}
function rejectAt$(x, vs) {
    for (var v of vs)
        x.delete(v);
    return x;
}
function rejectAt(x, vs) {
    return rejectAt$(new Set(x), vs);
}
function remove$(x, v) {
    x.delete(v);
    return x;
}
function remove(x, v) {
    return remove$(new Set(x), v);
}
function scanUntil(x, ft) {
    return find(x, ft);
}
function search(x, ft) {
    return find(x, ft);
}
function searchAll(x, ft) {
    return findAll(x, ft);
}
function shift$(x) {
    return drop$(x, 1);
}
function shift(x) {
    return drop(x, 1);
}
function size(x) {
    return x.size;
}
function some(x, ft = null) {
    var ft = ft || id;
    return scanUntil(x, ft) !== undefined;
}
function subset(x, n = -1, r = Math.random()) {
    var vs = subsequence([...x], n, r);
    return new Set(vs);
}
function* subsets(x, n = -1) {
    for (var vs of subsequences([...x], n))
        yield new Set(vs);
}
function symmetricDifference$(x, y) {
    for (var v of y) {
        if (x.has(v))
            x.delete(v);
        else
            x.add(v);
    }
    return x;
}
function symmetricDifference(x, y) {
    var a = new Set();
    for (var v of x)
        if (!y.has(v))
            a.add(v);
    for (var v of y)
        if (!x.has(v))
            a.add(v);
    return a;
}
function tail(x) {
    return drop(x, 1);
}
function take$(x, n = 1) {
    var i = 0;
    for (var v of x)
        if (i++ >= n)
            x.delete(v);
    return x;
}
function take(x, n = 1) {
    var i = 0, a = new Set();
    for (var v of x) {
        if (i++ >= n)
            break;
        a.add(v);
    }
    return a;
}
function union$(x, y) {
    return concat$(x, y);
}
function union(x, y) {
    return concat$(new Set(), x, y);
}
function value$1(x, r = Math.random()) {
    return value([...x], r);
}
function* values(x) {
    yield* x;
}
exports.add = add;
exports.add$ = add$;
exports.cartesianProduct = cartesianProduct;
exports.chunk = chunk$1;
exports.compare = compare;
exports.concat = concat;
exports.concat$ = concat$;
exports.count = count;
exports.countAs = countAs;
exports.difference = difference;
exports.difference$ = difference$;
exports.drop = drop;
exports.drop$ = drop$;
exports.entries = entries;
exports.entry = entry;
exports.every = every;
exports.filter = filter;
exports.filter$ = filter$;
exports.filterAt = filterAt;
exports.filterAt$ = filterAt$;
exports.find = find;
exports.findAll = findAll;
exports.flat = flat;
exports.flatMap = flatMap;
exports.forEach = forEach;
exports.from = from;
exports.from$ = from$;
exports.has = has;
exports.hasSubset = hasSubset;
exports.head = head;
exports.intersection = intersection;
exports.intersection$ = intersection$;
exports.is = is;
exports.isDisjoint = isDisjoint;
exports.isEmpty = isEmpty;
exports.isEqual = isEqual;
exports.join = join;
exports.length = length;
exports.map = map;
exports.map$ = map$;
exports.max = max;
exports.min = min;
exports.partition = partition;
exports.partitionAs = partitionAs;
exports.range = range;
exports.reduce = reduce;
exports.reject = reject;
exports.reject$ = reject$;
exports.rejectAt = rejectAt;
exports.rejectAt$ = rejectAt$;
exports.remove = remove;
exports.remove$ = remove$;
exports.scanUntil = scanUntil;
exports.scanWhile = scanWhile;
exports.search = search;
exports.searchAll = searchAll;
exports.shift = shift;
exports.shift$ = shift$;
exports.size = size;
exports.some = some;
exports.subset = subset;
exports.subsets = subsets;
exports.symmetricDifference = symmetricDifference;
exports.symmetricDifference$ = symmetricDifference$;
exports.tail = tail;
exports.take = take;
exports.take$ = take$;
exports.union = union;
exports.union$ = union$;
exports.value = value$1;
exports.values = values;
